I'm Cody MacLeod, a graduate at SNHU with a B.S. in Computer Science. This portfolio was created as the final project for CS 499 to showcase a few projects from prior courses that demonstrate a flexible skillset across the entire field. Below you'll find a self-assessment of my educational journey, an informal code review, and three enhanced projects highlighting different skillsets.


# Professional Self-Assessment
The process of creating this portfolio has provided a great opportunity to highlight my strengths as not just a programmer, but a professional in the field of Computer Science. While the artifacts below will showcase experience with multiple programming languages, data structures, databases, and more, I’ve learned many other valuable skills from my courses here. Before beginning the code, I’ve learned plenty of skills for planning ahead of time. In CS 230: Project Software Design, I learned how to interpret the needs of the user and clients and plan out strategies to fulfill these goals. Setting up detailed plans and proper documentation proved to be an invaluable skill for smooth deployment of a program. In CS 305 I further developed these skills to plan for proper security, learning industry standard mitigation techniques and best practices while getting vulnerability assessment experience.

From CS 250 I learned about the software development cycle, developing further skills to collect user stories and getting practice working in an Agile environment. Through that course I’ve worked through all the roles of a Scrum team, learning how to best communicate with shareholders and the skills necessary to be a valuable and helpful team member in collaborative environments. Meanwhile in CS 255 I had the chance to further practice properly communicating technical knowledge with different audiences as we created presentations to share how planned projects would meet business requirements to our clients.

In later classes I developed skills working with servers and databases through CS 340. Through that course we developed a client facing web application utilizing a MongoDB database. These skills were expanded upon in CS 465 where I worked as a full stack developer, designing the front and back end for a web application using a MEAN stack. In CS 300 I developed knowledge of data structures, using runtime analysis to weigh the pros and cons of different structures such as vectors, hash tables, and binary search trees.

To showcase all these skills developed throughout my educational journey, I’ve chosen two artifacts to enhance. The first artifact is from CS 320: Software Testing, Automation, and Quality Assurance where I developed the core components for a potential mobile application. The below enhancements will cover software engineering through the porting to a different programming language, and the use of unit tests. This artifact also provided a great opportunity to highlight the knowledge of data structures and algorithms through enhancements that prioritize the primary use case of the application and provided runtime analysis. The last artifact was an android application developed in CS 360: Mobile Architect and Programming, that stores and displays the user’s weight in an SQLite database. The enhancements made provide a great opportunity to showcase knowledge of databases and improved security.

# Code Review
In this code review I've explained the existing functionality, analyzed the efficiciency and documentation, and outlined the planned enhancements performed down below.

[Link to Youtube](https://youtu.be/TSCzj6SfTnw)

# Software Engineering
This artifact was the final project for CS 320: Software Testing, Automation, and Quality Assurance where the core functionality of a mobile service was developed to accept and manage user input for different components such as contacts and tasks. This project provided a great example of designing easily understood code through the separate classes designed for it. Most importantly, this project provided an opportunity to showcase automation and testing throughout the entire development process to ensure the code was not only error free but also meeting the client’s requirements.

Originally this program was designed in Java, of which I have done the most projects throughout my courses here at SNHU. To showcase experience with other languages, I chose to port it over to C++ while ensuring I maintained that same level of testing throughout the development process. In Java memory is automatically freed up, but in C++ memory management is done manually to offer finer control, making it an important consideration throughout development. This was most evident when working on the service classes as careless calls to the containers would simply make a copy of the vector instead of pointing to the same memory location of the original variables. For the Java version of this artifact, testing was primarily done with unit testing through the JUnit framework. As the name suggests, this framework only works with Java, so to meet similar coverage with the ported version I utilized Catch2, a lightweight and open-source unit testing framework.

Throughout development I focused on meeting the planned course outcomes for this project by demonstrating the ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals. It also briefly highlighted understanding of algorithmic principles through time complexity through the removal of nodes from the vector. I prioritized showcasing testing, understanding of the clients’ requirements, and readability throughout the enhancement process. The use of C++ header files proved to be especially helpful to separate declarations, making the code even more readable. The enhancements process was not without difficulties as C++ is likely the language I have the least experience with. While not difficult to learn how to utilize, it was my first experience using separate header files and the Catch2 framework. The biggest challenge came from learning memory management practices, particularly when it came to removing objects from the vector. Initial attempts were inefficient as it could potentially have to shift all the remaining elements in the vector, but using the erase-remove idiom, where both the standard erase() and remove() functions are utilized at the same time, the time complexity is greatly reduced by only having to eliminate the elements in one parse.

[Link to Original Artifact](https://github.com/CodyMacLeod/CS-320-Portfolio)

[Link to Enhanced Artifact](https://github.com/CodyMacLeod/codymacleod.github.io/tree/main/Mobile%20Services-%20C%2B%2B%20Conversion%20and%20Unit%20Tests)


# Algorithms and Data Structures
The artifact chosen for this enhancement was a continuation of the project chosen for software design and engineering, the final project for CS 320: Software Testing, Automation, and Quality Assurance. This project provided the core functionality of a mobile service to manage inputs of different components of a mobile application such as contacts and tasks. A core component of these programs is the data structures used for the service level classes. With the initial design they utilized an ArrayList and once ported to C++ it utilized a Vector. While this data structure is very efficient for adding new entries too, searching can be slow if the entry is at the back of the structure as it will have to search through every other entry to find it. Based off the requirements for this project to design these services for use as a mobile application, retrieving specific contacts or tasks will be the most utilized feature.

To enhance this artifact, I chose to modify the data structure to one that would be support this searching feature. With the initial implementation with an ArrayList or vector, the time complexity to search for an element would be O(n). With a hash table we’ll calculate a hash value from the unique ID to store the data at. In the case of a collision where both share the same hash, the data is stored in the bucket via a pointer to the next node. Usually, the search will find the initial key for the fastest search, meaning on average we’d have a constant complexity of O(1). In the worst case we’d have to travel through the bucket to find the node, resulting in the complexity of O(n), the same as the vector.

This program also showcased an opportunity to add more features to it. A potentially useful functionality for a mobile service would be the ability to see a list of all the contacts or tasks input, sorted alphabetically. Implementing this feature provided an opportunity to showcase experience with sorting algorithms. As this would be a less frequently used feature, converting the Hash Table to a vector to quick sort would provide a sufficient experience without slowing down the core functionality of searching.

Through this enhancement I’ve met the course outcome of designing and evaluating computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution while managing the trade-offs involved in design choices. This is best demonstrated in evaluating the most important functionality of the program and choosing the Hash Table that best supports it without trading away too much efficiency for other functions such as adding or removing new parts to the structure. The biggest challenges for this enhancement came from the design portion, having to evaluate which components would be most valuable to pick which data structure would best suffice. Had the alphabetical organization of the structures been a priority, then a structure such as Binary Search Tree may have been a better choice. This has helped improve my experience with the design process and planning before diving into implementation.

[Link to Original Artifact](https://github.com/CodyMacLeod/CS-320-Portfolio)

[Link to Enhanced Artifact](https://github.com/CodyMacLeod/codymacleod.github.io/tree/main/Mobile%20Services%20-%20HashTable%20Implementation)


# Databases
This artifact was the final project for CS 360: Mobile Architect and Programming. The purpose of this application was to create an android app that would allow the user to store their weight every day, making it easy to view progress on their weight loss journey. The project utilizes an SQLite Database to keep track of the entry date, weight value, and the weight goal the user is aiming for, making it a good opportunity to showcase experience working with databases. Since this project utilizes SQL, it also provided a good opportunity to highlight a security mindset by being prepared for SQL injection attacks.

Initially this artifact did not make great use of queries to allow the user to track their progress. While users could submit and delete entries, they did not have the means to sort it. To improve on this artifact, I allowed the user to sort by date, allowing them to easily see positive or negative trends in their weight loss journey. When selecting the date column, the order that the recycler view is populated with reverses, allowing the user to customize it to their liking, either seeing their journey from the beginning, or seeing the entries with the most recent dates first.

When working with SQL databases, it is incredibly important to be prepared for potentially malicious users trying to inject SQL to their inputs. To prevent this, inputs are parametrized so even if the user did input a SQL query, it would not be performed in the database. To further prevent errors, we’ve also limited the inputs, utilizing a date scroller to ensure the user must enter a valid date, and only allowing for double to be entered for their weight. When working with this database we made extensive use of cursors, so taking proper care to ensure they were always closed after use was important to keep in mind. Another important aspect of this artifact and why it was chosen is due to requiring user permission for more private information, such as sending alerts to the user when they’ve met their weight goal, demonstrating steps to ensure the users privacy. Through these extra steps taken I’ve showcased the final course outcome of developing a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources.

While modifying the artifact, the largest struggle came from updating the recycler view to properly display entries without requiring an entire page reload. While modifying the data retrieved from the select queries was relatively easy, having the recycler view adapter be aware of it proved a tad more difficult. After much experimentation, clearing the list before repopulating and then triggering a notification that the data set changed proved effective. This helped improve my knowledge with how the adapter interacts with changes to the data within it.

[Link to Original Artifact](https://github.com/CodyMacLeod/CS360-Portfolio)

[Link to Enhanced Artifact](https://github.com/CodyMacLeod/codymacleod.github.io/tree/main/Weight%20Tracking%20Application%20Enhanced)
